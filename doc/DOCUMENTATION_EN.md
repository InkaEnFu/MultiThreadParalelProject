Project Name:
Multithread Financial Monitor with Real-Time API

Author:
Matyáš Prokop

Contact:
inkaenfu69@gmail.com

School:
SPŠE Ječná

Date of Completion:
23 November 2025

Note:
This document is part of a school project.

**1. Purpose of the Application and User Requirements**

The application solves a real-world problem of parallel data processing:
monitoring live stock prices, calculating the portfolio value, and evaluating alerts in real time.

**Business Requirements (BR)**

BR1: The project must implement or extend an application that solves a real-world problem involving parallel or concurrent processes/threads.

BR2: The chosen problem must come from a realistic scenario

BR3: The software must be practically usable.

BR4: The solution must include a meaningful decomposition of the work into parallel or concurrent parts.

BR5: The parallel parts of the program must communicate or coordinate with each other.

BR6: The program must address synchronization and resource conflicts.

BR7: Projects that do not contain meaningful parallelism, communication, or shared/conflicting resources are considered insufficient and will be graded as failed.

BR8: Projects that naturally encounter well-known concurrency patterns or problems.

**Functional Requirements (FR)**

FR1: The application must periodically download real stock prices for all tickers entered by the user at startup.

FR2: The application must store current prices in shared state.

FR3: The application must calculate the real-time portfolio value.

FR4: The application must evaluate alerts (price > limit).

FR5: The application must log all events.

FR6: The program must run multithreaded and must not block the main thread.

FR7: The program must continue running until the user terminates it.

**Non-Functional Requirements (NFR)**

NFR1: API requests must be stable and must not block threads (timeout, error handling).

NFR2: Synchronization of shared data must be safe (thread-safe).

NFR3: The system must be resilient to API failures.

NFR4: Logging must not block the main execution flow.

NFR5: The program must be easily configurable.


**2. Application Architecture**

    The application is based on a producer–consumer architecture with multiple consumers and a GUI layer.
    * Based on my textual description of how the project works, the following ASCII architecture diagram was generated by ChatGPT.
    
                            +-------------------+
                            |    GUI Layer      |
                            | (main_window.py)  |
                            +--------+----------+
                                     |
                                     v
                            +-------------------+
                            | config_window.py  |
                            | (User Input)      |
                            +--------+----------+
                                     |
                                     v
                            +-------------------+
                            |   TradeEngine     |
                            +--------+----------+
                                     |
                                     v
                            +-------------------+
                            |   SharedState     |
                            +----+-----+--------+
                                 |     |
                                 |     v
                                 |  +------------------+
                                 |  | AlertConsumer    |
                                 |  +--------+---------+
                                 |           |
                                 |           v
                                 |    +-------------+
                                 |    |  log_queue  |
                                 |    +------+------+
                                 |           |
                                 |           v
                    +------------+-----------+----------------+
                    |                        |                |
                    v                        |                |
            +-------------------+            |                |
            |   PriceProducer   |            |                |
            +----------+--------+            |                |
                       |                     |                |
                       v                     |                |
                +-------------+              |                |
                | price_queue |              |                |
                +-------+-----+              |                |
                        |                    |                |
                        v                    |                |
            +-------------------+            |                |
            | PortfolioConsumer |            |                |
            +---------+---------+            |                |
                      |                      |                |
                      v                      |                |
                +-------------+<-------------+----------------+
                |  log_queue  |
                +------+------+ 
                       |
                       v
            +-------------------+
            | monitor_window.py |
            | (Real-time GUI)   |
            +-------------------+

**3. Component Descriptions**

**SharedState**

prices: dict[str, float]

portfolio: dict[str, int]

alerts: dict[str, float]

lock: threading.Lock

**GUI Layer**

main_window.py — Entry point GUI window with start/exit buttons and status display

config_window.py — Configuration dialog for adding stocks, shares, and setting alerts with ticker validation

monitor_window.py — Real-time monitoring window displaying portfolio value, current prices, and logs

**PriceProducer**

Periodically (configurable, default every 2 seconds) downloads stock prices via yfinance and inserts them into work_queue.

**PortfolioConsumer**

Processes prices from the work queue, locks shared state during updates, recalculates portfolio value, and sends messages to log_queue.

**AlertConsumer**

Periodically reads shared state under a lock, checks defined alert limits, and sends alerts to log_queue when exceeded.

**TradeEngine**

Coordinates the entire system, initializes all queues, threads, and shared state, and starts/stops the worker threads.


**4. Behavioral Model (Activity Diagram – Text Form)**

**GUI Initialization Phase**

The application starts with a graphical interface:

Display main window with "Start Configuration" button

User clicks "Start Configuration"

Open config_window (configuration dialog)

User enters stock ticker

System validates ticker existence via yfinance

User enters number of shares

User optionally sets alert price

User clicks "Add" to add stock to portfolio

Repeat for additional stocks

User clicks "Finish and start"

Pass portfolio, alerts, and symbols to TradeEngine

**TradeEngine** 

The TradeEngine acts as the coordinator of the entire application:

Creates SharedState

Initializes internal queues (price_queue, log_queue)

Creates all worker threads:

PriceProducer

PortfolioConsumer

AlertConsumer

Starts all threads in the correct order

Opens monitor_window for real-time display

Ensures the system remains active until user closes the window

The TradeEngine does not process business logic itself — it orchestrates the worker threads that perform the work.

**PriceProducer**

Wait for a fixed interval (default 2 s)

Download the latest prices for all watched symbols

Insert each price into work_queue

Insert an informational message into log_queue

Repeat indefinitely

**PortfolioConsumer**

Wait for new data in work_queue

Acquire SharedState.lock

Update prices

Recalculate portfolio_value

Release lock

Log the updated value to log_queue

Repeat indefinitely

**AlertConsumer**

Acquire SharedState.lock

For each ticker with an alert, compare current price with threshold

If the threshold is exceeded, write an alert message to log_queue

Release lock

Sleep briefly (default 1 s)

Repeat indefinitely

**Monitor Window**

Read messages from log_queue

Display them in the GUI log panel

Update price table with current stock prices

Update portfolio value display

Highlight alerts with red background

Repeat every 2 seconds

**5. Libraries and Interfaces Used**
Python Standard Library

threading

queue

time

tkinter — GUI framework (included with Python)

Third-Party Libraries

yfinance — wrapper for Yahoo Finance API

pytest - for testing project

API Services

Yahoo Finance (via yfinance)

**6. Licensing Aspects**

yfinance: Apache 2.0 License

Yahoo Finance data is publicly accessible; recommended for non-commercial and educational use according to service terms

Project: school assignment

**7. Application Configuration**

The application is configured through a graphical user interface (GUI). Users interact with dialog windows to add stocks, set shares, and configure alerts before the monitoring engine starts. -> python main.py

**8. Testing and Validation**

Performed tests:

Test 1 – test_portfolio_value_update.py – Verifies portfolio recalculation

This test checks that after two manual price updates, the correct stock prices are stored and the final portfolio value is computed accurately.

Test 2 – test_alert_creation.py – Verifies alert generation

This test simulates a price that exceeds the alert threshold and checks that an alert message is correctly logged.

Test 3 – test_log_error.py – Verifies producer error handling

This test runs the PriceProducer without any symbols and verifies that it logs the expected “No symbols defined” error.

Test 4 – test_price_calculation.py – Verifies multi-price updates

This test ensures that the PortfolioConsumer correctly updates multiple stock prices and recalculates the portfolio value accordingly.

**9. Version List and Known Bugs**

Version 1.0 — 23 November 2025
First version of the project; meets assignment requirements.

Known bugs:

occasional API outages (network issues) — handled with retry/backoff

API may return NaN values — handled in code (ignored/not overwriting values)

Version 1.1 - 30 November 2025

Added interactive console input for portfolio and alert configuration, introduced ticker validation, and refactored architecture

Known bugs:

Negative user input for prices 

Version 2.0 - 7 December 2025

Migrated from console interface to graphical user interface (GUI) using tkinter. Added main_window, config_window, and monitor_window for real-time portfolio monitoring. Removed LoggerThread as GUI now handles all display.

Known bugs:

None reported 


**10. Installation and Running the Application**

Requirements:

Python 3.10+

Install dependencies:

Terminal:

pip install -r requirements.txt


Run the application:

python main.py

Run the test:

$env:PYTHONPATH="."
pytest tests/